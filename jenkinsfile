pipeline {
    agent any
    
    environment {
        AWS_REGION = 'us-east-1'
        AWS_ACCOUNT_ID = '833371734412'
        ECR_REGISTRY = '833371734412.dkr.ecr.us-east-1.amazonaws.com'
        ECR_REPOSITORY = 'nginx-web-site'
        IMAGE_TAG = 'v1'
        CLUSTER_NAME = 'nginx-web-site-cluster'
        SERVICE_NAME = 'nginx-web-site-task-service-b2igefhw'
        TASK_FAMILY = 'nginx-web-site-task'
    }

    stages {
        stage('Build Docker Image') {
            steps {
                sh 'docker build -t ${ECR_REPOSITORY}:${IMAGE_TAG} .'
                sh 'docker tag ${ECR_REPOSITORY}:${IMAGE_TAG} ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}'
                echo "‚úÖ Imagem Docker criada"
            }
        }
        
        stage('Test Docker Image') {
            steps {
                sh '''
                    echo "üß™ Testando imagem Docker..."
                    docker run --rm -d --name test-nginx ${ECR_REPOSITORY}:${IMAGE_TAG}
                    sleep 5
                    CONTAINER_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' test-nginx)
                    echo "üîç Testando container no IP: $CONTAINER_IP"
                    curl -f http://$CONTAINER_IP || (docker logs test-nginx && docker stop test-nginx && exit 1)
                    docker stop test-nginx
                    echo "‚úÖ Teste da imagem passou!"
                '''
            }
        }
        
        stage('Push to ECR') {
            steps {
                withCredentials([aws(credentialsId: 'aws-access-key', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    sh '''
                        echo "üîë Fazendo login no ECR..."
                        aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REGISTRY}
                        echo "üì§ Enviando imagem para ECR..."
                        docker push ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}
                        echo "‚úÖ Imagem enviada para ECR"
                    '''
                }
            }
        }
        
        stage('Deploy to Fargate') {
            steps {
                withCredentials([aws(credentialsId: 'aws-access-key', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    sh '''
                        echo "üöÄ Atualizando aplica√ß√£o no Fargate..."
                        
                        # Criar nova task definition com a nova imagem
                        NEW_TASK_DEF=$(aws ecs register-task-definition \
                            --family ${TASK_FAMILY} \
                            --network-mode awsvpc \
                            --requires-compatibilities FARGATE \
                            --cpu 256 \
                            --memory 512 \
                            --execution-role-arn "arn:aws:iam::${AWS_ACCOUNT_ID}:role/ecsTaskExecutionRole" \
                            --task-role-arn "arn:aws:iam::${AWS_ACCOUNT_ID}:role/ecsTaskExecutionRole" \
                            --container-definitions '[{
                                "name": "nginx-container",
                                "image": "'${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}'",
                                "essential": true,
                                "portMappings": [{"containerPort": 80, "protocol": "tcp"}],
                                "logConfiguration": {
                                    "logDriver": "awslogs",
                                    "options": {
                                        "awslogs-group": "/ecs/nginx-web-site",
                                        "awslogs-create-group": "true",
                                        "awslogs-region": "'${AWS_REGION}'",
                                        "awslogs-stream-prefix": "ecs"
                                    }
                                }
                            }]' \
                            --region ${AWS_REGION} \
                            --query 'taskDefinition.taskDefinitionArn' \
                            --output text)
                        
                        echo "üìù Nova task definition: $NEW_TASK_DEF"
                        
                        # Atualizar o servi√ßo
                        aws ecs update-service \
                            --cluster ${CLUSTER_NAME} \
                            --service ${SERVICE_NAME} \
                            --task-definition "$NEW_TASK_DEF" \
                            --region ${AWS_REGION}
                        
                        echo "‚úÖ Servi√ßo atualizado! Aguardando deploy..."
                        
                        # Aguardar deploy completar
                        aws ecs wait services-stable \
                            --cluster ${CLUSTER_NAME} \
                            --services ${SERVICE_NAME} \
                            --region ${AWS_REGION}
                        
                        echo "üéâ Deploy conclu√≠do com sucesso!"
                        
                        # Mostrar URL da aplica√ß√£o com tratamento de erro melhorado
                        echo "üîç Buscando informa√ß√µes da aplica√ß√£o..."
                        sleep 10  # Aguardar task ficar completamente ativa
                        
                        TASK_ARN=$(aws ecs list-tasks --cluster ${CLUSTER_NAME} --service-name ${SERVICE_NAME} --region ${AWS_REGION} --query 'taskArns[0]' --output text 2>/dev/null)
                        
                        if [ "$TASK_ARN" != "None" ] && [ ! -z "$TASK_ARN" ]; then
                            echo "‚úÖ Task encontrada: $TASK_ARN"
                            
                            # Buscar ENI com tratamento de erro
                            ENI_ID=$(aws ecs describe-tasks --cluster ${CLUSTER_NAME} --tasks "$TASK_ARN" --region ${AWS_REGION} --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' --output text 2>/dev/null || echo "")
                            
                            if [ ! -z "$ENI_ID" ] && [ "$ENI_ID" != "None" ]; then
                                echo "‚úÖ Network interface encontrada: $ENI_ID"
                                
                                # Buscar IP p√∫blico com tratamento de erro
                                PUBLIC_IP=$(aws ec2 describe-network-interfaces --network-interface-ids "$ENI_ID" --region ${AWS_REGION} --query 'NetworkInterfaces[0].Association.PublicIp' --output text 2>/dev/null || echo "")
                                
                                if [ ! -z "$PUBLIC_IP" ] && [ "$PUBLIC_IP" != "None" ] && [ "$PUBLIC_IP" != "null" ]; then
                                    echo "üåê Aplica√ß√£o dispon√≠vel em: http://$PUBLIC_IP"
                                    echo "‚úÖ Deploy finalizado com sucesso!"
                                else
                                    echo "‚ö†Ô∏è IP p√∫blico n√£o dispon√≠vel ainda"
                                    echo "üìã Verifique o console AWS ECS para obter o IP"
                                fi
                            else
                                echo "‚ö†Ô∏è Network interface n√£o encontrada ou ainda sendo configurada"
                                echo "üìã Verifique o console AWS ECS - a aplica√ß√£o pode estar inicializando"
                            fi
                        else
                            echo "‚ö†Ô∏è Nenhuma task ativa encontrada"
                            echo "üìã Verifique o console AWS ECS para status das tasks"
                        fi
                        
                        echo ""
                        echo "üìä Status do servi√ßo:"
                        aws ecs describe-services --cluster ${CLUSTER_NAME} --services ${SERVICE_NAME} --region ${AWS_REGION} --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount}' --output table || echo "Erro ao obter status"
                    '''
                }
            }
        }
    }
    
    post {
        always {
            sh 'docker rmi ${ECR_REPOSITORY}:${IMAGE_TAG} || true'
            sh 'docker rmi ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG} || true'
        }
        success { echo 'üéâ Pipeline executado com sucesso!' }
        failure { echo '‚ùå Pipeline falhou!' }
    }
}