pipeline {
    agent any
    
    environment {
        AWS_REGION = 'us-east-1'
        AWS_ACCOUNT_ID = '833371734412'
        ECR_REGISTRY = '833371734412.dkr.ecr.us-east-1.amazonaws.com'
        ECR_REPOSITORY = 'nginx-web-site'
        IMAGE_TAG = 'v1'
        CLUSTER_NAME = 'nginx-web-site-cluster'
        SERVICE_NAME = 'nginx-web-site-task-service-b2igefhw'
        TASK_FAMILY = 'nginx-web-site-task'
        
        TF_VAR_aws_region = 'us-east-1'
        TF_VAR_environment = 'dev'
        TF_VAR_project_name = 'nginx-web-site'
        TF_VAR_aws_account_id = '833371734412'
    }

    stages {
        stage('Checkout') {
            steps {
                echo "Code already in workspace"
                echo "Listing project files..."
                sh 'ls -la'
                sh 'ls -la terraform/ || echo "Terraform directory not found"'
            }
        }
        
        stage('Terraform Init') {
            steps {
                withCredentials([aws(credentialsId: 'aws-access-key', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    dir('terraform') {
                        sh '''
                            echo "Initializing Terraform..."
                            terraform --version
                            terraform init
                            echo "Terraform initialized!"
                        '''
                    }
                }
            }
        }
        
        stage('Terraform Plan') {
            steps {
                withCredentials([aws(credentialsId: 'aws-access-key', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    dir('terraform') {
                        sh '''
                            echo "Running Terraform Plan..."
                            terraform plan -out=tfplan
                            echo "Terraform Plan completed!"
                        '''
                    }
                }
            }
        }
        
        stage('Terraform Apply - Approval') {
            steps {
                script {
                    echo "Waiting for approval to apply infrastructure changes..."
                    input message: 'Apply Terraform changes to AWS infrastructure?', 
                          ok: 'Apply',
                          submitterParameter: 'APPROVER'
                    echo "Approval received from: ${env.APPROVER}"
                }
            }
        }
        
        stage('Terraform Apply') {
            steps {
                withCredentials([aws(credentialsId: 'aws-access-key', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    dir('terraform') {
                        sh '''
                            echo "Applying Terraform changes..."
                            terraform apply tfplan
                            echo "Infrastructure updated!"
                            
                            echo "Created/updated resources:"
                            terraform output
                        '''
                    }
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                sh 'docker build -t ${ECR_REPOSITORY}:${IMAGE_TAG} .'
                sh 'docker tag ${ECR_REPOSITORY}:${IMAGE_TAG} ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}'
                echo "Docker image created"
            }
        }
        
        stage('Test Docker Image') {
            steps {
                sh '''
                    echo "Testing Docker image..."
                    docker run --rm -d --name test-nginx ${ECR_REPOSITORY}:${IMAGE_TAG}
                    sleep 5
                    CONTAINER_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' test-nginx)
                    echo "Testing container at IP: $CONTAINER_IP"
                    curl -f http://$CONTAINER_IP || (docker logs test-nginx && docker stop test-nginx && exit 1)
                    docker stop test-nginx
                    echo "Image test passed!"
                '''
            }
        }
        
        stage('SonarQube Analysis') {
            steps {
                script {
                    def scannerHome = tool 'SonarQube Scanner'
                    withSonarQubeEnv('SonarQube') {
                        sh """
                            echo "Starting code quality analysis..."
                            echo "Scanner path: ${scannerHome}"
                            ${scannerHome}/bin/sonar-scanner \\
                                -Dsonar.projectKey=nginx-web-site \\
                                -Dsonar.projectName="Nginx Web Site" \\
                                -Dsonar.projectVersion=1.0 \\
                                -Dsonar.sources=. \\
                                -Dsonar.exclusions="**/node_modules/**,**/target/**,**/.git/**,**/docker-compose.yml,**/terraform/.terraform/**,**/*.tfstate*,**/*.tfplan" \\
                                -Dsonar.inclusions="**/*.html,**/*.css,**/*.js,**/*.sh,**/Dockerfile,**/jenkinsfile,**/*.tf" \\
                                -Dsonar.sourceEncoding=UTF-8
                            echo "SonarQube analysis completed!"
                        """
                    }
                }
            }
        }
        
        stage('Quality Gate') {
            steps {
                script {
                    echo "Waiting for Quality Gate result..."
                    timeout(time: 10, unit: 'MINUTES') {
                        def qg = waitForQualityGate()
                        if (qg.status != 'OK') {
                            echo "Quality Gate failed: ${qg.status}"
                            echo "Aborting deploy due to code quality issues"
                            error "Pipeline aborted due to Quality Gate: ${qg.status}"
                        } else {
                            echo "Quality Gate passed! Proceeding with deploy..."
                        }
                    }
                }
            }
        }
        
        stage('Push to ECR') {
            steps {
                withCredentials([aws(credentialsId: 'aws-access-key', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    sh '''
                        echo "Logging into ECR..."
                        aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REGISTRY}
                        echo "Pushing image to ECR..."
                        docker push ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}
                        echo "Image pushed to ECR"
                    '''
                }
            }
        }
        
        stage('Deploy to Fargate') {
            steps {
                withCredentials([aws(credentialsId: 'aws-access-key', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY')]) {
                    sh '''
                        echo "Updating application on Fargate..."
                        
                        NEW_TASK_DEF=$(aws ecs register-task-definition \
                            --family ${TASK_FAMILY} \
                            --network-mode awsvpc \
                            --requires-compatibilities FARGATE \
                            --cpu 256 \
                            --memory 512 \
                            --execution-role-arn "arn:aws:iam::${AWS_ACCOUNT_ID}:role/ecsTaskExecutionRole" \
                            --task-role-arn "arn:aws:iam::${AWS_ACCOUNT_ID}:role/ecsTaskExecutionRole" \
                            --container-definitions '[{
                                "name": "nginx-container",
                                "image": "'${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}'",
                                "essential": true,
                                "portMappings": [{"containerPort": 80, "protocol": "tcp"}],
                                "logConfiguration": {
                                    "logDriver": "awslogs",
                                    "options": {
                                        "awslogs-group": "/ecs/nginx-web-site",
                                        "awslogs-create-group": "true",
                                        "awslogs-region": "'${AWS_REGION}'",
                                        "awslogs-stream-prefix": "ecs"
                                    }
                                }
                            }]' \
                            --region ${AWS_REGION} \
                            --query 'taskDefinition.taskDefinitionArn' \
                            --output text)
                        
                        echo "New task definition: $NEW_TASK_DEF"
                        
                        aws ecs update-service \
                            --cluster ${CLUSTER_NAME} \
                            --service ${SERVICE_NAME} \
                            --task-definition "$NEW_TASK_DEF" \
                            --region ${AWS_REGION}
                        
                        echo "Service updated! Waiting for deployment..."
                        
                        aws ecs wait services-stable \
                            --cluster ${CLUSTER_NAME} \
                            --services ${SERVICE_NAME} \
                            --region ${AWS_REGION}
                        
                        echo "Deploy completed successfully!"
                        
                        echo "Searching for application information..."
                        sleep 10
                        
                        TASK_ARN=$(aws ecs list-tasks --cluster ${CLUSTER_NAME} --service-name ${SERVICE_NAME} --region ${AWS_REGION} --query 'taskArns[0]' --output text 2>/dev/null)
                        
                        if [ "$TASK_ARN" != "None" ] && [ ! -z "$TASK_ARN" ]; then
                            echo "Task found: $TASK_ARN"
                            
                            ENI_ID=$(aws ecs describe-tasks --cluster ${CLUSTER_NAME} --tasks "$TASK_ARN" --region ${AWS_REGION} --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' --output text 2>/dev/null || echo "")
                            
                            if [ ! -z "$ENI_ID" ] && [ "$ENI_ID" != "None" ]; then
                                echo "Network interface found: $ENI_ID"
                                
                                PUBLIC_IP=$(aws ec2 describe-network-interfaces --network-interface-ids "$ENI_ID" --region ${AWS_REGION} --query 'NetworkInterfaces[0].Association.PublicIp' --output text 2>/dev/null || echo "")
                                
                                if [ ! -z "$PUBLIC_IP" ] && [ "$PUBLIC_IP" != "None" ] && [ "$PUBLIC_IP" != "null" ]; then
                                    echo "Application available at: http://$PUBLIC_IP"
                                    echo "Deploy finalized successfully!"
                                else
                                    echo "Public IP not available yet"
                                    echo "Check AWS ECS console for IP"
                                fi
                            else
                                echo "Network interface not found or still being configured"
                                echo "Check AWS ECS console - application may be initializing"
                            fi
                        else
                            echo "No active task found"
                            echo "Check AWS ECS console for task status"
                        fi
                        
                        echo ""
                        echo "Service status:"
                        aws ecs describe-services --cluster ${CLUSTER_NAME} --services ${SERVICE_NAME} --region ${AWS_REGION} --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount}' --output table || echo "Error getting status"
                    '''
                }
            }
        }
    }
    
    post {
        always {
            sh 'docker rmi ${ECR_REPOSITORY}:${IMAGE_TAG} || true'
            sh 'docker rmi ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG} || true'
        }
        success { echo 'Pipeline executed successfully!' }
        failure { echo 'Pipeline failed!' }
    }
}